""" python dataclasses of the data in the AIPE MongoDB

these dataclasses were largely auto-generated by exporting MongoDB AIPE experiments to JSON and converting the resulting schema to python classes using [quicktype](https://github.com/quicktype/quicktype).

`from/to_{datatype}` functions are used to assert correct datatypes when converting from/to dictionaries.

`{dataclass}.from_dict()` methods should be used to instantiate the dataclasses with datatype assertions. `{dataclass}.to_dict()` can be used to receive the python dictionaries which behave just the same as the original untyped AIPE data dictionaries.

The main dataclass is the `ExperimentFromDb` class describing a single experiment carried out. all other dataclasses are nested attributes of this class.

"""


from abc import ABC
from dataclasses import dataclass
import logging
from datetime import datetime
from typing import Any, Optional, Union, TypeVar, Callable, Type, cast, List, Dict
import dateutil.parser

T = TypeVar("T")


def from_str(x: Any) -> str:
    if not isinstance(x, str):
        ret = str(x)
        return ret
    else:
        return x


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


def from_float(x: Any) -> float:
    assert isinstance(x, (float, int)) and not isinstance(x, bool)
    return float(x)


def from_bool(x: Any) -> bool:
    if not isinstance(x, bool):
        assert not isinstance(x, str)
        ret = bool(x)
        return ret
    return x


def to_float(x: Any) -> float:
    assert isinstance(x, float)
    return x


def from_none(x: Any) -> Any:
    assert x is None
    return x


def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False


def from_datetime(x: Any) -> datetime:
    if isinstance(x, datetime):
        return x
    else:
        return dateutil.parser.parse(x)


def from_int(x: Any) -> int:
    assert isinstance(x, int) and not isinstance(x, bool)
    return x


def from_dict(f: Callable[[Any], T], x: Any) -> Dict[str, T]:
    assert isinstance(x, dict)
    return {k: f(v) for (k, v) in x.items()}


@dataclass
class AllParameterElement:
    t: str
    v: List['AllParameterElement']

    @staticmethod
    def from_dict(obj: Any) -> 'AllParameterElement':
        assert isinstance(obj, dict)
        t = from_str(obj.get("_t"))
        v = from_list(AllParameterElement.from_dict, obj.get("_v"))
        return AllParameterElement(t, v)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_t"] = from_str(self.t)
        result["_v"] = from_list(lambda x: to_class(
            AllParameterElement, x), self.v)
        return result


@dataclass
class ChangedUIParameter:
    ''' a parameter changed by the expert using the user interface'''
    label: str
    user_value: str
    key: str
    original_value: str = "-1"
    extruder: str = ""
    category: str = ""

    @staticmethod
    def from_dict(obj: Any) -> 'ChangedUIParameter':
        assert isinstance(obj, dict)
        label = from_str(obj.get("label"))
        user_value = from_str(obj.get("user_value"))
        original_value = from_str(obj.get("original_value", "-1"))
        extruder = from_str(obj.get("extruder", ""))
        key = from_str(obj.get("key", label.lower().replace(" ", "_")))
        category = from_str(obj.get("category", ""))
        return ChangedUIParameter(label, user_value, key, original_value, extruder,  category)

    def to_dict(self) -> dict:
        result: dict = {}
        result["label"] = from_str(self.label)
        result["user_value"] = from_str(self.user_value)
        result["original_value"] = from_str(self.original_value)
        result["extruder"] = from_str(self.extruder)
        result["key"] = from_str(self.key)
        result["category"] = from_str(self.category)
        return result


@dataclass
class Parameter(ABC):
    ''' abstract base class for different kinds of parameters, which may be influential'''
    value: Union[float, str, bool]
    influential: bool


@dataclass
class NumericParameter(Parameter):
    value: float
    influential: bool

    @staticmethod
    def from_dict(obj: Any) -> 'NumericParameter':
        assert isinstance(obj, dict)
        value = from_float(obj.get("value"))
        influential = from_bool(obj.get("influential"))
        return NumericParameter(value, influential)

    def to_dict(self) -> dict:
        result: dict = {}
        result["value"] = to_float(self.value)
        result["influential"] = from_bool(self.influential)
        return result


@dataclass
class StringParameter(Parameter):
    value: str
    influential: bool

    @staticmethod
    def from_dict(obj: Any) -> 'StringParameter':
        assert isinstance(obj, dict)
        value = from_str(obj.get("value"))
        influential = from_bool(obj.get("influential"))
        return StringParameter(value, influential)

    def to_dict(self) -> dict:
        result: dict = {}
        result["value"] = from_str(self.value)
        result["influential"] = from_bool(self.influential)
        return result


@dataclass
class BooleanParameter(Parameter):
    value: bool
    influential: bool

    @staticmethod
    def from_dict(obj: Any) -> 'BooleanParameter':
        assert isinstance(obj, dict)
        value = from_bool(obj.get("value"))
        influential = from_bool(obj.get("influential"))
        return BooleanParameter(value, influential)

    def to_dict(self) -> dict:
        result: dict = {}
        result["value"] = from_bool(self.value)
        result["influential"] = from_bool(self.influential)
        return result


class ParameterBuilder:
    @staticmethod
    def build_parameter(value, influential=False):
        if isinstance(value, float) or isinstance(value, int):
            return NumericParameter(value, influential)
        elif isinstance(value, str):
            return StringParameter(value, influential)
        elif isinstance(value, bool):
            return BooleanParameter(value, influential)
        else:
            raise TypeError("unsupported parameter type.")


@dataclass
class Influence:
    '''non-quality-rating influences'''
    material_color: Optional[StringParameter] = None
    material_producer: Optional[StringParameter] = None
    material_type: Optional[StringParameter] = None
    temperature: Optional[NumericParameter] = None
    humidity: Optional[NumericParameter] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Influence':
        assert isinstance(obj, dict)
        material_color = from_union(
            [StringParameter.from_dict, from_none], obj.get("material_color"))
        material_producer = from_union(
            [StringParameter.from_dict, from_none], obj.get("material_producer"))
        material_type = from_union(
            [StringParameter.from_dict, from_none], obj.get("material_type"))
        temperature = from_union(
            [NumericParameter.from_dict, from_none], obj.get("temperature"))
        humidity = from_union(
            [NumericParameter.from_dict, from_none], obj.get("humidity"))
        return Influence(material_color, material_producer, material_type, temperature, humidity)

    def to_dict(self) -> dict:
        result: dict = {}
        result["material_color"] = from_union(
            [lambda x: to_class(StringParameter, x), from_none], self.material_color)
        result["material_producer"] = from_union(
            [lambda x: to_class(StringParameter, x), from_none], self.material_producer)
        result["material_type"] = from_union(
            [lambda x: to_class(StringParameter, x), from_none], self.material_type)
        result["temperature"] = from_union(
            [lambda x: to_class(NumericParameter, x), from_none], self.temperature)
        result["humidity"] = from_union(
            [lambda x: to_class(NumericParameter, x), from_none], self.humidity)
        return result


@dataclass
class Rating:
    ''' rating of the created experiment object by the expert'''
    user_id: str
    rating_date: datetime
    blobs: float
    gaps: float
    layer_misalignment: float
    layer_separation: float
    over_extrusion: float
    line_misalignment: float
    stringing: float
    under_extrusion: float
    warping: float
    poor_bridging: float
    burning: float
    overall_ok: bool
    lost_adhesion: bool
    not_labelable: bool
    comment: str

    @staticmethod
    def from_dict(obj: Any) -> 'Rating':
        assert isinstance(obj, dict)
        user_id = from_str(obj.get("user_id"))
        rating_date = from_datetime(obj.get("rating_date"))
        blobs = from_float(obj.get("blobs"))
        gaps = from_float(obj.get("gaps"))
        layer_misalignment = from_float(obj.get("layer_misalignment"))
        layer_separation = from_float(obj.get("layer_separation"))
        over_extrusion = from_float(obj.get("over_extrusion"))
        line_misalignment = from_float(obj.get("line_misalignment"))
        stringing = from_float(obj.get("stringing"))
        under_extrusion = from_float(obj.get("under_extrusion"))
        warping = from_float(obj.get("warping"))
        poor_bridging = from_float(obj.get("poor_bridging"))
        burning = from_float(obj.get("burning"))
        overall_ok = from_bool(obj.get("overall_ok"))
        lost_adhesion = from_bool(obj.get("lost_adhesion"))
        not_labelable = from_bool(obj.get("not_labelable"))
        comment = from_str(obj.get("comment"))
        return Rating(user_id, rating_date, blobs, gaps, layer_misalignment, layer_separation, over_extrusion, line_misalignment, stringing, under_extrusion, warping, poor_bridging, burning, overall_ok, lost_adhesion, not_labelable, comment)

    def to_dict(self) -> dict:
        result: dict = {}
        result["user_id"] = from_str(self.user_id)
        result["rating_date"] = self.rating_date.isoformat()
        result["blobs"] = from_float(self.blobs)
        result["gaps"] = from_float(self.gaps)
        result["layer_misalignment"] = from_float(self.layer_misalignment)
        result["layer_separation"] = from_float(self.layer_separation)
        result["over_extrusion"] = from_float(self.over_extrusion)
        result["line_misalignment"] = from_float(self.line_misalignment)
        result["stringing"] = from_float(self.stringing)
        result["under_extrusion"] = from_float(self.under_extrusion)
        result["warping"] = from_float(self.warping)
        result["poor_bridging"] = from_float(self.poor_bridging)
        result["burning"] = from_float(self.burning)
        result["overall_ok"] = from_bool(self.overall_ok)
        result["lost_adhesion"] = from_bool(self.lost_adhesion)
        result["not_labelable"] = from_bool(self.not_labelable)
        result["comment"] = from_str(self.comment)
        return result


@dataclass
class LastRatingInfluence:
    ''' a reference to the previous experiment with a remark which parameter has influenced the latest rating change'''
    experiment_id: int
    layer_misalignment: NumericParameter
    overall: BooleanParameter
    line_misalignment: NumericParameter
    burning: NumericParameter
    warping: NumericParameter
    layer_separation: NumericParameter
    lost_adhesion: BooleanParameter
    blobs: NumericParameter
    comment: StringParameter
    gaps: NumericParameter
    under_extrusion: NumericParameter
    stringing: NumericParameter
    poor_bridging: NumericParameter
    over_extrusion: NumericParameter
    not_labelable: BooleanParameter

    @staticmethod
    def from_dict(obj: Any) -> 'LastRatingInfluence':
        assert isinstance(obj, dict)
        experiment_id = from_int(obj["experiment_id"].get("value"))
        layer_misalignment = NumericParameter.from_dict(
            obj.get("layerMisalignment"))
        stringing = NumericParameter.from_dict(obj.get("stringing"))
        line_misalignment = NumericParameter.from_dict(
            obj.get("lineMisalignment"))
        burning = NumericParameter.from_dict(obj.get("burning"))
        layer_separation = NumericParameter.from_dict(
            obj.get("layerSeparation"))
        poor_bridging = NumericParameter.from_dict(obj.get("poorBridging"))
        over_extrusion = NumericParameter.from_dict(obj.get("overExtrusion"))
        warping = NumericParameter.from_dict(obj.get("warping"))
        lost_adhesion = BooleanParameter.from_dict(obj.get("lostAdhesion"))
        under_extrusion = NumericParameter.from_dict(obj.get("underExtrusion"))
        not_labelable = BooleanParameter.from_dict(obj.get("notLabelable"))
        comment = StringParameter.from_dict(obj.get("comment"))
        gaps = NumericParameter.from_dict(obj.get("gaps"))
        blobs = NumericParameter.from_dict(obj.get("blobs"))
        overall = BooleanParameter.from_dict(obj.get("overall"))
        return LastRatingInfluence(experiment_id, layer_misalignment, overall, line_misalignment, burning, warping, layer_separation, lost_adhesion, blobs, comment, gaps, under_extrusion, stringing, poor_bridging, over_extrusion, not_labelable)

    def to_dict(self) -> Dict[str, Parameter]:
        result: dict = {}
        result["experiment_id"] = from_int(self.experiment_id)
        result["layerMisalignment"] = to_class(
            NumericParameter, self.layer_misalignment)
        result["stringing"] = to_class(NumericParameter, self.stringing)
        result["lineMisalignment"] = to_class(
            NumericParameter, self.line_misalignment)
        result["burning"] = to_class(NumericParameter, self.burning)
        result["layerSeparation"] = to_class(
            NumericParameter, self.layer_separation)
        result["poorBridging"] = to_class(NumericParameter, self.poor_bridging)
        result["overExtrusion"] = to_class(
            NumericParameter, self.over_extrusion)
        result["warping"] = to_class(NumericParameter, self.warping)
        result["lostAdhesion"] = to_class(BooleanParameter, self.lost_adhesion)
        result["underExtrusion"] = to_class(
            NumericParameter, self.under_extrusion)
        result["notLabelable"] = to_class(BooleanParameter, self.not_labelable)
        result["comment"] = to_class(StringParameter, self.comment)
        result["gaps"] = to_class(NumericParameter, self.gaps)
        result["blobs"] = to_class(NumericParameter, self.blobs)
        result["overall"] = to_class(BooleanParameter, self.overall)
        return result

    def to_rating(self, _user_id, _rating_date) -> Rating:
        lri_data = self.to_dict()
        del lri_data['experiment_id']
        rating_data = {param_name: param.value for param_name,
                       param in lri_data.items()}

        result: Rating = Rating(_user_id,
                                _rating_date,
                                **rating_data)
        return result


@dataclass
class Insights:
    ''' insights about ratings of an experiment as entered by the expert who carried it out.'''
    comment: str
    influences: List[Influence]
    changed_ui_parameters: List[ChangedUIParameter]
    user_id: str
    uncertainty: float
    last_rating_influences: List[Union[LastRatingInfluence, None]]

    @staticmethod
    def from_dict(obj: Any) -> 'Insights':
        assert isinstance(obj, dict)
        comment = from_str(obj.get("comment"))
        influences = from_list(Influence.from_dict, obj.get("influences"))
        changed_ui_parameters = from_list(
            ChangedUIParameter.from_dict, obj.get("changed_ui_parameters"))
        user_id = from_str(obj.get("user_id"))
        last_rating_influences = from_list(lambda x: from_union(
            [LastRatingInfluence.from_dict, from_none], x), obj.get("last_rating_influences"))
        uncertainty = from_float(obj.get("uncertainty"))
        return Insights(comment, influences, changed_ui_parameters, user_id, uncertainty, last_rating_influences)

    def to_dict(self) -> dict:
        result: dict = {}
        result["comment"] = from_str(self.comment)
        result["influences"] = from_list(
            lambda x: to_class(Influence, x), self.influences)
        result["changed_ui_parameters"] = from_list(lambda x: to_class(
            ChangedUIParameter, x), self.changed_ui_parameters)
        result["user_id"] = from_str(self.user_id)
        result["last_rating_influences"] = from_list(lambda x: from_union(
            [lambda y: to_class(LastRatingInfluence, y), from_none], x), self.last_rating_influences)
        result["uncertainty"] = to_float(self.uncertainty)
        return result


@dataclass
class Material:
    ''' producer, type and color of the material used'''
    material_color: str = "sdg_color"
    material_type: str = "sdg_type"
    material_producer: str = "sdg"

    @staticmethod
    def from_dict(obj: Any) -> 'Material':
        assert isinstance(obj, dict)
        material_color = from_str(obj.get("material_color", "sdg_color"))
        material_type = from_str(obj.get("material_type", "sdg_type"))
        material_producer = from_str(obj.get("material_producer", "sdg"))
        return Material(material_color, material_type, material_producer)

    def to_dict(self) -> dict:
        result: dict = {}
        result["material_color"] = from_str(self.material_color)
        result["material_type"] = from_str(self.material_type)
        result["material_producer"] = from_str(self.material_producer)
        return result


@dataclass
class Measurement:
    ''' environmental measurements'''
    humidity: float
    temperature: float
    time: datetime

    @staticmethod
    def from_dict(obj: Any) -> 'Measurement':
        assert isinstance(obj, dict)
        humidity = from_float(obj.get("humidity"))
        temperature = from_float(obj.get("temperature"))
        time = from_datetime(obj.get("time"))
        return Measurement(humidity, temperature, time)

    def to_dict(self) -> dict:
        result: dict = {}
        result["humidity"] = to_float(self.humidity)
        result["temperature"] = to_float(self.temperature)
        result["time"] = self.time.strftime("%d.%m.%Y %H:%M:%S")
        return result


@dataclass
class ExperimentFromDb:
    ''' a single experiment carried out complying with the AIPE interface.'''
    id: int
    printer: str
    stl_file_id: str
    material: Material
    oneoff: bool
    all_parameters: Dict[str, Union[bool, AllParameterElement, float, str]]
    insights: Insights
    measurements: List[Measurement]
    completion: float
    ratings: List[Rating]
    series_id: str

    @staticmethod
    def from_dict(obj: Any) -> 'ExperimentFromDb':
        assert isinstance(obj, dict)
        _id = from_int(obj.get("_id"))
        printer = from_str(obj.get("printer"))
        stl_file_id = from_str(obj.get("stl_file_id"))
        material = Material.from_dict(obj.get("material"))
        oneoff = from_bool(obj.get("oneoff"))
        all_parameters = from_dict(lambda x: from_union(
            [from_float, AllParameterElement.from_dict, from_bool, from_str], x), obj.get("all_parameters"))
        insights = Insights.from_dict(obj.get("insights"))
        measurements = from_list(
            Measurement.from_dict, obj.get("measurements"))
        completion = from_float(obj.get("completion"))
        ratings = from_list(Rating.from_dict, obj.get("ratings"))
        series_id = from_str(obj.get("series_id"))
        return ExperimentFromDb(_id, printer, stl_file_id, material, oneoff, all_parameters, insights, measurements, completion, ratings, series_id)

    def to_dict(self) -> Dict[str, Any]:
        result: dict = {}
        result["_id"] = from_int(self.id)
        result["printer"] = from_str(self.printer)
        result["stl_file_id"] = from_str(self.stl_file_id)
        result["material"] = to_class(Material, self.material)
        result["oneoff"] = from_bool(self.oneoff)
        result["all_parameters"] = from_dict(lambda x: from_union([from_float, lambda y: to_class(
            AllParameterElement, y), from_bool, from_str], x), self.all_parameters)
        result["insights"] = to_class(Insights, self.insights)
        result["measurements"] = from_list(
            lambda x: to_class(Measurement, x), self.measurements)
        result["completion"] = to_float(self.completion)
        result["ratings"] = from_list(
            lambda x: to_class(Rating, x), self.ratings)
        result["series_id"] = from_str(self.series_id)
        return result


def experiment_from_db_from_dict(s: Any) -> List[ExperimentFromDb]:
    return from_list(ExperimentFromDb.from_dict, s)


def experiment_from_db_to_dict(x: List[ExperimentFromDb]) -> Any:
    return from_list(lambda y: to_class(ExperimentFromDb, y), x)


#                               ----  ExperimentSeries        ----
#                          return value of "dp._determine_experiment_series_for_one_offs"

ExperimentSeries = Dict[str, List[int]]
'''return value of `dp._determine_experiment_series_for_one_offs`. series of experiments (IDs), mapped to hash based on model, user id, printer_id & experiment id. e.g. `{'d3ZSeWbB': [5, 6]}` '''
ExperimentDict = Dict[str, Any]

#                               ----  ParsedExperiment        ----
#                          return value of "dp.parse_experiment"
# this is unused as of right now, may be deleted later on


@dataclass
class ParsedExperiment:
    id: int
    completion: int
    printer: str
    material_print_temperature_layer_0: int
    material_bed_temperature: int
    print_bed_temperature: int
    cool_fan_speed_min: int
    material_bed_temperature_layer_0: int
    speed_topbottom: int
    speed_travel_layer_0: int
    speed_infill: int
    retraction_speed: int
    speed_travel: int
    cool_fan_speed: int
    retraction_amount: int
    cool_fan_speed_max: int
    speed_wall_0: int
    speed_ironing: int
    speed_wall_x: int
    speed_print_layer_0: int
    bridge_fan_speed: int
    retraction_extrusion_window: int
    speed_print: int
    retraction_prime_speed: int
    speed_wall: int
    material_print_temperature: int
    speed_roofing: int
    retraction_retract_speed: int
    blobs: int
    gaps: int
    layer_misalignment: int
    layer_separation: int
    over_extrusion: int
    line_misalignment: int
    stringing: int
    under_extrusion: int
    warping: int
    poor_bridging: int
    overall_ok: int
    lost_adhesion: int
    not_labelable: int
    burning: int
    humidity: int
    temperature: int
    material_color: str
    material_type: str
    material_producer: str

    @staticmethod
    def from_dict(obj: Any) -> 'ParsedExperiment':
        assert isinstance(obj, dict)
        _id = from_int(obj.get("ID"))
        completion = from_int(obj.get("completion"))
        printer = from_str(obj.get("printer"))
        material_print_temperature_layer_0 = from_int(
            obj.get("material_print_temperature_layer_0"))
        material_bed_temperature = from_int(
            obj.get("material_bed_temperature"))
        print_bed_temperature = from_int(obj.get("print_bed_temperature"))
        cool_fan_speed_min = from_int(obj.get("cool_fan_speed_min"))
        material_bed_temperature_layer_0 = from_int(
            obj.get("material_bed_temperature_layer_0"))
        speed_topbottom = from_int(obj.get("speed_topbottom"))
        speed_travel_layer_0 = from_int(obj.get("speed_travel_layer_0"))
        speed_infill = from_int(obj.get("speed_infill"))
        retraction_speed = from_int(obj.get("retraction_speed"))
        speed_travel = from_int(obj.get("speed_travel"))
        cool_fan_speed = from_int(obj.get("cool_fan_speed"))
        retraction_amount = from_int(obj.get("retraction_amount"))
        cool_fan_speed_max = from_int(obj.get("cool_fan_speed_max"))
        speed_wall_0 = from_int(obj.get("speed_wall_0"))
        speed_ironing = from_int(obj.get("speed_ironing"))
        speed_wall_x = from_int(obj.get("speed_wall_x"))
        speed_print_layer_0 = from_int(obj.get("speed_print_layer_0"))
        bridge_fan_speed = from_int(obj.get("bridge_fan_speed"))
        retraction_extrusion_window = from_int(
            obj.get("retraction_extrusion_window"))
        speed_print = from_int(obj.get("speed_print"))
        retraction_prime_speed = from_int(obj.get("retraction_prime_speed"))
        speed_wall = from_int(obj.get("speed_wall"))
        material_print_temperature = from_int(
            obj.get("material_print_temperature"))
        speed_roofing = from_int(obj.get("speed_roofing"))
        retraction_retract_speed = from_int(
            obj.get("retraction_retract_speed"))
        blobs = from_int(obj.get("blobs"))
        gaps = from_int(obj.get("gaps"))
        layer_misalignment = from_int(obj.get("layer_misalignment"))
        layer_separation = from_int(obj.get("layer_separation"))
        over_extrusion = from_int(obj.get("over_extrusion"))
        line_misalignment = from_int(obj.get("line_misalignment"))
        stringing = from_int(obj.get("stringing"))
        under_extrusion = from_int(obj.get("under_extrusion"))
        warping = from_int(obj.get("warping"))
        poor_bridging = from_int(obj.get("poor_bridging"))
        overall_ok = from_int(obj.get("overall_ok"))
        lost_adhesion = from_int(obj.get("lost_adhesion"))
        not_labelable = from_int(obj.get("not_labelable"))
        burning = from_int(obj.get("burning"))
        humidity = from_int(obj.get("humidity"))
        temperature = from_int(obj.get("temperature"))
        material_color = from_str(obj.get("material_color"))
        material_type = from_str(obj.get("material_type"))
        material_producer = from_str(obj.get("material_producer"))
        return ParsedExperiment(_id, completion, printer, material_print_temperature_layer_0, material_bed_temperature, print_bed_temperature, cool_fan_speed_min, material_bed_temperature_layer_0, speed_topbottom, speed_travel_layer_0, speed_infill, retraction_speed, speed_travel, cool_fan_speed, retraction_amount, cool_fan_speed_max, speed_wall_0, speed_ironing, speed_wall_x, speed_print_layer_0, bridge_fan_speed, retraction_extrusion_window, speed_print, retraction_prime_speed, speed_wall, material_print_temperature, speed_roofing, retraction_retract_speed, blobs, gaps, layer_misalignment, layer_separation, over_extrusion, line_misalignment, stringing, under_extrusion, warping, poor_bridging, overall_ok, lost_adhesion, not_labelable, burning, humidity, temperature, material_color, material_type, material_producer)

    def to_dict(self) -> dict:
        result: dict = {}
        result["ID"] = from_int(self.id)
        result["completion"] = from_int(self.completion)
        result["printer"] = from_str(self.printer)
        result["material_print_temperature_layer_0"] = from_int(
            self.material_print_temperature_layer_0)
        result["material_bed_temperature"] = from_int(
            self.material_bed_temperature)
        result["print_bed_temperature"] = from_int(self.print_bed_temperature)
        result["cool_fan_speed_min"] = from_int(self.cool_fan_speed_min)
        result["material_bed_temperature_layer_0"] = from_int(
            self.material_bed_temperature_layer_0)
        result["speed_topbottom"] = from_int(self.speed_topbottom)
        result["speed_travel_layer_0"] = from_int(self.speed_travel_layer_0)
        result["speed_infill"] = from_int(self.speed_infill)
        result["retraction_speed"] = from_int(self.retraction_speed)
        result["speed_travel"] = from_int(self.speed_travel)
        result["cool_fan_speed"] = from_int(self.cool_fan_speed)
        result["retraction_amount"] = from_int(self.retraction_amount)
        result["cool_fan_speed_max"] = from_int(self.cool_fan_speed_max)
        result["speed_wall_0"] = from_int(self.speed_wall_0)
        result["speed_ironing"] = from_int(self.speed_ironing)
        result["speed_wall_x"] = from_int(self.speed_wall_x)
        result["speed_print_layer_0"] = from_int(self.speed_print_layer_0)
        result["bridge_fan_speed"] = from_int(self.bridge_fan_speed)
        result["retraction_extrusion_window"] = from_int(
            self.retraction_extrusion_window)
        result["speed_print"] = from_int(self.speed_print)
        result["retraction_prime_speed"] = from_int(
            self.retraction_prime_speed)
        result["speed_wall"] = from_int(self.speed_wall)
        result["material_print_temperature"] = from_int(
            self.material_print_temperature)
        result["speed_roofing"] = from_int(self.speed_roofing)
        result["retraction_retract_speed"] = from_int(
            self.retraction_retract_speed)
        result["blobs"] = from_int(self.blobs)
        result["gaps"] = from_int(self.gaps)
        result["layer_misalignment"] = from_int(self.layer_misalignment)
        result["layer_separation"] = from_int(self.layer_separation)
        result["over_extrusion"] = from_int(self.over_extrusion)
        result["line_misalignment"] = from_int(self.line_misalignment)
        result["stringing"] = from_int(self.stringing)
        result["under_extrusion"] = from_int(self.under_extrusion)
        result["warping"] = from_int(self.warping)
        result["poor_bridging"] = from_int(self.poor_bridging)
        result["overall_ok"] = from_int(self.overall_ok)
        result["lost_adhesion"] = from_int(self.lost_adhesion)
        result["not_labelable"] = from_int(self.not_labelable)
        result["burning"] = from_int(self.burning)
        result["humidity"] = from_int(self.humidity)
        result["temperature"] = from_int(self.temperature)
        result["material_color"] = from_str(self.material_color)
        result["material_type"] = from_str(self.material_type)
        result["material_producer"] = from_str(self.material_producer)
        return result


def parsed_experiment_from_dict(s: Any) -> ParsedExperiment:
    return ParsedExperiment.from_dict(s)


def parsed_experiment_to_dict(x: ParsedExperiment) -> Any:
    return to_class(ParsedExperiment, x)
